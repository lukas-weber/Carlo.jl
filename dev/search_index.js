var documenterSearchIndex = {"docs":
[{"location":"evaluables.html#evaluables","page":"Evaluables","title":"Evaluables","text":"","category":"section"},{"location":"evaluables.html","page":"Evaluables","title":"Evaluables","text":"In addition to simply calculating the averages of some observables in your Monte Carlo simulations, sometimes you are also interested in quantities that are functions of these observables, such as the Binder cumulant which is related to the ratio of moments of the magnetization.","category":"page"},{"location":"evaluables.html","page":"Evaluables","title":"Evaluables","text":"This presents two problems. First, estimating the errors of such quantities is not trivial due to correlations. Second, simply computing functions of quantities with errorbars incurs a bias.","category":"page"},{"location":"evaluables.html","page":"Evaluables","title":"Evaluables","text":"Luckily, Carlo can help you with this by letting you define such quantities – we call them evaluables – in the Carlo.register_evaluables(YourMC, eval, params) function.","category":"page"},{"location":"evaluables.html","page":"Evaluables","title":"Evaluables","text":"This function gets an Evaluator which can be used to","category":"page"},{"location":"evaluables.html","page":"Evaluables","title":"Evaluables","text":"evaluate!","category":"page"},{"location":"evaluables.html#Carlo.evaluate!","page":"Evaluables","title":"Carlo.evaluate!","text":"evaluate!(func::Function, eval::Evaluator, name::Symbol, (ingredients::Symbol...))\n\nDefine an evaluable called name, i.e. a quantity depending on the observable averages ingredients.... The function func will get the ingredients as parameters and should return the value of the evaluable. Carlo will then perform jackknifing to calculate a bias-corrected result with correct error bars that appears together with the observables in the result file.\n\n\n\n\n\n","category":"function"},{"location":"evaluables.html#Example","page":"Evaluables","title":"Example","text":"","category":"section"},{"location":"evaluables.html","page":"Evaluables","title":"Evaluables","text":"This is an example for a register_evaluables implementation for a model of a magnet.","category":"page"},{"location":"evaluables.html","page":"Evaluables","title":"Evaluables","text":"using Carlo\nstruct YourMC <: AbstractMC end # hide\n\nfunction Carlo.register_evaluables(\n    ::Type{YourMC},\n    eval::Evaluator,\n    params::AbstractDict,\n)\n\n    T = params[:T]\n    Lx = params[:Lx]\n    Ly = get(params, :Ly, Lx)\n    \n    evaluate!(eval, :Susceptibility, (:Magnetization2,)) do mag2\n        return Lx * Ly * mag2 / T\n    end\n\n    evaluate!(eval, :BinderRatio, (:Magnetization2, :Magnetization4)) do mag2, mag4\n        return mag2 * mag2 / mag4\n    end\n\n    return nothing\nend","category":"page"},{"location":"evaluables.html","page":"Evaluables","title":"Evaluables","text":"Note that this code is called after the simulation is over, so there is no way to access the simulation state. However, it is possible to get the needed information about the system (e.g. temperature, system size) from the task parameters params.","category":"page"},{"location":"parallel_run_mode.html#parallel_run_mode","page":"Parallel run mode","title":"Parallel run mode","text":"","category":"section"},{"location":"parallel_run_mode.html","page":"Parallel run mode","title":"Parallel run mode","text":"One of Carlo’s features is to automatically parallelize independent Monte Carlo simulation runs over MPI. These runs can either share the same set of parameters – in which case their results are averaged – or have different parameters entirely.","category":"page"},{"location":"parallel_run_mode.html","page":"Parallel run mode","title":"Parallel run mode","text":"Sometimes this kind of trivial parallelism is not satisfactory. For example, it does not shorten the time needed for thermalization, and some Monte Carlo algorithms can benefit from some sort of population control that exchanges data between different simulations of the same random process.","category":"page"},{"location":"parallel_run_mode.html","page":"Parallel run mode","title":"Parallel run mode","text":"For these cases, Carlo features a parallel run mode where each Carlo run does not run on one but multiple MPI ranks. Parallel run mode is enabled in JobInfo by passing the ranks_per_run argument. ","category":"page"},{"location":"parallel_run_mode.html#Parallel-AbstractMC-interface","page":"Parallel run mode","title":"Parallel AbstractMC interface","text":"","category":"section"},{"location":"parallel_run_mode.html","page":"Parallel run mode","title":"Parallel run mode","text":"In order to use parallel run mode, the Monte Carlo algorithm must implement a modified version of the AbstractMC interface including additional MPI.Comm arguments that allow coordination between the different ranks per run.","category":"page"},{"location":"parallel_run_mode.html","page":"Parallel run mode","title":"Parallel run mode","text":"The first three functions","category":"page"},{"location":"parallel_run_mode.html","page":"Parallel run mode","title":"Parallel run mode","text":"Carlo.init!(mc::YourMC, ctx::MCContext, params::AbstractDict, comm::MPI.Comm)\nCarlo.sweep!(mc::YourMC, ctx::MCContext, comm::MPI.Comm)\nCarlo.measure!(mc::YourMC, ctx::MCContext, comm::MPI.Comm)","category":"page"},{"location":"parallel_run_mode.html","page":"Parallel run mode","title":"Parallel run mode","text":"simply receive an additional comm argument. An important restriction here is that only rank 0 can make measurements on the given MCContext, so you are responsible to communicate the measurement results to that rank.","category":"page"},{"location":"parallel_run_mode.html","page":"Parallel run mode","title":"Parallel run mode","text":"For checkpointing, there is a similar catch.","category":"page"},{"location":"parallel_run_mode.html","page":"Parallel run mode","title":"Parallel run mode","text":"Carlo.write_checkpoint(mc::YourMC, out::Union{HDF5.Group,Nothing}, comm::MPI.Comm)\nCarlo.read_checkpoint!(mc::YourMC, in::Union{HDF5.Group,Nothing}, comm::MPI.Comm)","category":"page"},{"location":"parallel_run_mode.html","page":"Parallel run mode","title":"Parallel run mode","text":"In these methods, only rank 0 receives an HDF5.Group and the other ranks need to communicate. Carlo does not use the collective writing mode of parallel HDF5.","category":"page"},{"location":"parallel_run_mode.html","page":"Parallel run mode","title":"Parallel run mode","text":"Lastly, the Carlo.register_evaluables function remains the same as in the normal interface.","category":"page"},{"location":"jobtools.html#jobtools","page":"JobTools","title":"JobTools","text":"","category":"section"},{"location":"jobtools.html","page":"JobTools","title":"JobTools","text":"This submodule contains tools to specify or read job information necessary to run Carlo calculations.","category":"page"},{"location":"jobtools.html","page":"JobTools","title":"JobTools","text":"JobInfo\nTaskInfo\nresult_filename\nstart(job::JobInfo,::AbstractVector{<:AbstractString})","category":"page"},{"location":"jobtools.html#Carlo.JobTools.JobInfo","page":"JobTools","title":"Carlo.JobTools.JobInfo","text":"JobInfo(\n    job_directory_prefix::AbstractString,\n    mc::Type;\n    checkpoint_time::Union{AbstractString, Dates.Second},\n    run_time::Union{AbstractString, Dates.Second},\n    tasks::Vector{TaskInfo},\n    rng::Type = Random.Xoshiro,\n    ranks_per_run::Union{Integer, Symbol} = 1,\n)\n\nHolds all information required for a Monte Carlo calculation. The data of the calculation (parameters, results, and checkpoints) will be saved under job_directory_prefix.\n\nmc is the the type of the algorithm to use, implementing the abstract_mc interface.\n\ncheckpoint_time and run_time specify the interval between checkpoints and the total desired run_time of the simulation. Both may be specified as a string of format [[hours:]minutes:]seconds\n\nEach job contains a set of tasks, corresponding to different sets of simulation parameters that should be run in parallel. The TaskMaker type can be used to conveniently generate them.\n\nrng sets the type of random number generator that should be used.\n\nSetting the optional parameter ranks_per_run > 1 enables Parallel run mode. The special value ranks_per_run = :all uses all available ranks for a single run.\n\n\n\n\n\n","category":"type"},{"location":"jobtools.html#Carlo.JobTools.TaskInfo","page":"JobTools","title":"Carlo.JobTools.TaskInfo","text":"TaskInfo(name::AbstractString, params::Dict{Symbol,Any})\n\nHolds information of one parameter set in a Monte Carlo calculation. While it is possible to construct it by hand, for multiple tasks, it is recommended to use TaskMaker for convenience.\n\nSpecial parameters\n\nWhile params can hold any kind of parameter, some are special and used to configure the behavior of Carlo.\n\nsweeps: required. The minimum number of Monte Carlo measurement sweeps to perform for the task.\nthermalization: required. The number of thermalization sweeps to perform.\nbinsize: required. The internal default binsize for observables. Carlo will merge this many samples into one bin before saving them.   On top of this, a rebinning analysis is performed, so that this setting mostly affects disk space and IO efficiency. To get correct autocorrelation times, it should be 1. In all other cases much higher.\nrng: optional. Type of the random number generator to use. See rng.\nseed: optional. Optionally run calculations with a fixed seed. Useful for debugging.\nrebin_length: optional. Override the automatic rebinning length chosen by Carlo (⚠ do not set without knowing what you are doing).\nrebin_sample_skip: optional. Skip the first N internal bins of each run when performing the rebinning analysis. Useful if thermalization was not set high enough at the start of the simulation.\nmax_runs_per_task: optional. If set, puts a limit on the maximum number of runs that will be scheduled for this task.\n\nOut of these parameters, it is only permitted to change sweeps for an existing calculation. This is handy to run the simulation for longer or shorter than planned originally.\n\n\n\n\n\n","category":"type"},{"location":"jobtools.html#Carlo.JobTools.result_filename","page":"JobTools","title":"Carlo.JobTools.result_filename","text":"result_filename(job::JobInfo)\n\nReturns the filename of the .results.json file containing the merged results of the calculation of job.\n\n\n\n\n\n","category":"function"},{"location":"jobtools.html#Carlo.start-Tuple{JobInfo, AbstractVector{<:AbstractString}}","page":"JobTools","title":"Carlo.start","text":"start(job::JobInfo, ARGS)\n\nCall this from your job script to start the Carlo command line interface.\n\nIf for any reason you do not want to use job scripts, you can directly schedule a job using\n\nstart(Carlo.MPIScheduler, job)\n\n\n\n\n\n","category":"method"},{"location":"jobtools.html#TaskMaker","page":"JobTools","title":"TaskMaker","text":"","category":"section"},{"location":"jobtools.html","page":"JobTools","title":"JobTools","text":"TaskMaker\ntask\nmake_tasks\ncurrent_task_name","category":"page"},{"location":"jobtools.html#Carlo.JobTools.TaskMaker","page":"JobTools","title":"Carlo.JobTools.TaskMaker","text":"TaskMaker()\n\nTool for generating a list of tasks, i.e. parameter sets, to be simulated in a Monte Carlo simulation.\n\nThe fields of TaskMaker can be freely assigned and each time task is called, their current state will be copied into a new task. Finally the list of tasks can be generated using make_tasks\n\nIn most cases the resulting tasks will be used in the constructor of JobInfo, the basic description for jobs in Carlo.\n\nExample\n\nThe following example creates a list of 5 tasks for different parameters T. This could be a scan of the finite-temperature phase diagram of some model. The first task will be run with more sweeps than the rest.\n\ntm = TaskMaker()\ntm.sweeps = 10000\ntm.thermalization = 2000\ntm.binsize = 500\n\ntask(tm; T=0.04)\ntm.sweeps = 5000\nfor T in range(0.1, 10, length=5)\n    task(tm; T=T)\nend\n\ntasks = make_tasks(tm)\n\n\n\n\n\n","category":"type"},{"location":"jobtools.html#Carlo.JobTools.task","page":"JobTools","title":"Carlo.JobTools.task","text":"task(tm::TaskMaker; kwargs...)\n\nCreates a new task for the current set of parameters saved in tm. Optionally, kwargs can be used to specify parameters that are set for this task only.\n\n\n\n\n\n","category":"function"},{"location":"jobtools.html#Carlo.JobTools.make_tasks","page":"JobTools","title":"Carlo.JobTools.make_tasks","text":"make_tasks(tm::TaskMaker)::Vector{TaskInfo}\n\nGenerate a list of tasks from tm based on the previous calls of task. The output of this will typically be supplied to the tasks argument of JobInfo.\n\n\n\n\n\n","category":"function"},{"location":"jobtools.html#Carlo.JobTools.current_task_name","page":"JobTools","title":"Carlo.JobTools.current_task_name","text":"current_task_name(tm::TaskMaker)\n\nReturns the name of the task that will be created by task(tm).\n\n\n\n\n\n","category":"function"},{"location":"abstract_mc.html#abstract_mc","page":"Implementing your algorithm","title":"Implementing your algorithm","text":"","category":"section"},{"location":"abstract_mc.html","page":"Implementing your algorithm","title":"Implementing your algorithm","text":"To run your own Monte Carlo algorithm with Carlo, you need to implement the AbstractMC interface documented in this file. For an example implementation showcasing all the features, take a look at the Ising example implementation.","category":"page"},{"location":"abstract_mc.html","page":"Implementing your algorithm","title":"Implementing your algorithm","text":"Carlo.AbstractMC","category":"page"},{"location":"abstract_mc.html#Carlo.AbstractMC","page":"Implementing your algorithm","title":"Carlo.AbstractMC","text":"This type is an interface for implementing your own Monte Carlo algorithm that will be run by Carlo.\n\n\n\n\n\n","category":"type"},{"location":"abstract_mc.html","page":"Implementing your algorithm","title":"Implementing your algorithm","text":"The following methods all need to be defined for your Monte Carlo algoritm type (here referred to as YourMC <: AbstractMC). See Parallel run mode for a slightly different interface that allows inner MPI parallelization of your algorithm.","category":"page"},{"location":"abstract_mc.html","page":"Implementing your algorithm","title":"Implementing your algorithm","text":"Carlo.init!\nCarlo.sweep!\nCarlo.measure!\nCarlo.write_checkpoint\nCarlo.read_checkpoint!\nCarlo.register_evaluables","category":"page"},{"location":"abstract_mc.html#Carlo.init!","page":"Implementing your algorithm","title":"Carlo.init!","text":"Carlo.init!(mc::YourMC, ctx::MCContext, params::AbstractDict)\n\nExecuted when a simulation is started from scratch.\n\n\n\n\n\n","category":"function"},{"location":"abstract_mc.html#Carlo.sweep!","page":"Implementing your algorithm","title":"Carlo.sweep!","text":"Carlo.sweep!(mc::YourMC, ctx::MCContext)\n\nPerform one Monte Carlo sweep or update to the configuration.\n\nnote: Note\nDoing measurements is supported during this step as some algorithms require doing so for efficiency. Remember to check for is_thermalized in that case.\n\n\n\n\n\n","category":"function"},{"location":"abstract_mc.html#Carlo.measure!","page":"Implementing your algorithm","title":"Carlo.measure!","text":"Carlo.measure!(mc::YourMC, ctx::MCContext)\n\nPerform one Monte Carlo measurement.\n\n\n\n\n\n","category":"function"},{"location":"abstract_mc.html#Carlo.write_checkpoint","page":"Implementing your algorithm","title":"Carlo.write_checkpoint","text":"Carlo.write_checkpoint(mc::YourMC, out::HDF5.Group)\n\nSave the complete state of the simulation to out.\n\n\n\n\n\n","category":"function"},{"location":"abstract_mc.html#Carlo.read_checkpoint!","page":"Implementing your algorithm","title":"Carlo.read_checkpoint!","text":"Carlo.read_checkpoint!(mc::YourMC, in::HDF5.Group)\n\nRead the state of the simulation from in.\n\n\n\n\n\n","category":"function"},{"location":"abstract_mc.html#Carlo.register_evaluables","page":"Implementing your algorithm","title":"Carlo.register_evaluables","text":"Carlo.register_evaluables(mc::Type{YourMC}, eval::Evaluator, params::AbstractDict)\n\nThis function is used to calculate postprocessed quantities from quantities that were measured during the simulation. Common examples are variances or ratios of observables.\n\nSee evaluables for more details.\n\n\n\n\n\n","category":"function"},{"location":"abstract_mc.html#mc_context","page":"Implementing your algorithm","title":"Interfacing with Carlo features","text":"","category":"section"},{"location":"abstract_mc.html","page":"Implementing your algorithm","title":"Implementing your algorithm","text":"The MCContext type, passed to your code by some of the functions above enables to use some features provided by Carlo.","category":"page"},{"location":"abstract_mc.html","page":"Implementing your algorithm","title":"Implementing your algorithm","text":"MCContext\nis_thermalized\nmeasure!(::MCContext, ::Symbol, ::Any)","category":"page"},{"location":"abstract_mc.html#Carlo.MCContext","page":"Implementing your algorithm","title":"Carlo.MCContext","text":"Holds the Carlo-internal state of the simulation and provides an interface to\n\nRandom numbers: the public field MCContext.rng is a random number generator (see rng)\nMeasurements: see measure!(::MCContext, ::Symbol, ::Any)\nSimulation state: see is_thermalized\n\n\n\n\n\n","category":"type"},{"location":"abstract_mc.html#Carlo.is_thermalized","page":"Implementing your algorithm","title":"Carlo.is_thermalized","text":"is_thermalized(ctx::MCContext)::Bool\n\nReturns true if the simulation is thermalized.\n\n\n\n\n\n","category":"function"},{"location":"abstract_mc.html#Carlo.measure!-Tuple{MCContext, Symbol, Any}","page":"Implementing your algorithm","title":"Carlo.measure!","text":"measure!(ctx::MCContext, name::Symbol, value)\n\nMeasure a sample for the observable named name. The sample value may be either a scalar or vector of a float type. \n\n\n\n\n\n","category":"method"},{"location":"resulttools.html#result_tools","page":"ResultTools","title":"ResultTools","text":"","category":"section"},{"location":"resulttools.html","page":"ResultTools","title":"ResultTools","text":"This is a small module to ease importing Carlo results back into Julia. It contains the function","category":"page"},{"location":"resulttools.html","page":"ResultTools","title":"ResultTools","text":"Carlo.ResultTools.dataframe","category":"page"},{"location":"resulttools.html#Carlo.ResultTools.dataframe","page":"ResultTools","title":"Carlo.ResultTools.dataframe","text":"ResultTools.dataframe(result_json::AbstractString)\n\nHelper to import result data from a *.results.json file produced after a Carlo calculation. Returns a Tables.jl-compatible dictionary that can be used as is or converted into a DataFrame or other table structure. Observables and their errorbars will be converted to Measurements.jl measurements.\n\n\n\n\n\n","category":"function"},{"location":"resulttools.html","page":"ResultTools","title":"ResultTools","text":"If we use ResultTools with DataFrames.jl to read out the results of the Ising example, it would be the following.","category":"page"},{"location":"resulttools.html","page":"ResultTools","title":"ResultTools","text":"using Plots\nusing DataFrames\nusing Carlo.ResultTools\n\ndf = DataFrame(ResultTools.dataframe(\"example.results.json\"))\n\nplot(df.T, df.Energy; xlabel = \"Temperature\", ylabel=\"Energy per spin\", group=df.Lx, legendtitle=\"L\")","category":"page"},{"location":"resulttools.html","page":"ResultTools","title":"ResultTools","text":"In the plot we can nicely see how the model approaches the ground state energy at low temperatures.","category":"page"},{"location":"index.html#Carlo.jl","page":"Carlo.jl","title":"Carlo.jl","text":"","category":"section"},{"location":"index.html#Overview","page":"Carlo.jl","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"Carlo is a framework that aims to simplify the implementation of high-performance Monte Carlo codes by handling the parallelization, checkpointing and error analysis. What sets it apart is a focus on ease of use and minimalism.","category":"page"},{"location":"index.html#Installation","page":"Carlo.jl","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"Installation is simple via the Julia REPL.","category":"page"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"] add Carlo","category":"page"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"If you wish to use the system MPI implementation, take a look at the MPI.jl documentation and be aware that in that case also the system binary of HDF5 as described here!","category":"page"},{"location":"index.html#Usage","page":"Carlo.jl","title":"Usage","text":"","category":"section"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"In order to work with Carlo, a Monte Carlo algorithm has to implement the AbstractMC interface. A full example of this is given in the reference implementation for the Ising model.","category":"page"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"Then, to perform simulation, one writes a job script defining all the parameters needed for the simulation, which could look something like the following.","category":"page"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"#!/usr/bin/env julia\n\nusing Carlo\nusing Carlo.JobTools\nusing Ising\n\ntm = TaskMaker()\ntm.sweeps = 10000\ntm.thermalization = 2000\ntm.binsize = 100\n\ntm.Lx = 10\ntm.Ly = 10\n\nTs = range(0.1, 4, length=20)\nfor T in Ts\n    task(tm; T=T)\nend\n\njob = JobInfo(@__FILE__, Ising.MC;\n    checkpoint_time=\"30:00\",\n    run_time=\"15:00\",\n    tasks=make_tasks(tm)\n)\n\nstart(dummy, dummy2) = nothing # hide\nstart(job, ARGS)","category":"page"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"This example starts a simulation for the Ising model on the 10×10 lattice for 20 different temperatures. Using the function start(job::JobInfo, ARGS) enables the Carlo CLI when we  execute the script above as follows.","category":"page"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"./myjob --help","category":"page"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"The command line interface allows (re)starting a job, merging preliminary results, and showing the completion status of a calculation.","category":"page"},{"location":"index.html#Starting-jobs","page":"Carlo.jl","title":"Starting jobs","text":"","category":"section"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"./myjob run","category":"page"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"This will start a simulation on a single core. To use multiple cores, use MPI.","category":"page"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"mpirun -n $num_cores ./myjob run","category":"page"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"Once the simulation is started, a directory myjob.data will be created to store all simulation data. The name of the directory corresponds to the first argument of JobInfo. Usually that will be @__FILE__, but you could also collect your simulation data in a different directory.","category":"page"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"The data directory will contain hdf5 files for each task of the job that contain checkpointing snapshots and measurement results. Once the job is done, Carlo will average the measurement data for you and produce the file myjob.results.json in the same directory as the myjob.data directory. This file contains means and errorbars of all observables. See ResultTools for some tips on consuming this file back into julia for your plotting or other postprocessing.","category":"page"},{"location":"index.html#Job-status","page":"Carlo.jl","title":"Job status","text":"","category":"section"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"./myjob status","category":"page"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"Use this command to find out the state of the simulation. It will show a table with the number of completed measurement sweeps, the target number of sweeps, the numbers of runs, and the fraction of them that is thermalized.","category":"page"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"The fraction is defined as thermalization sweeps completed/total thermalization sweeps needed.","category":"page"},{"location":"index.html#Merging-jobs","page":"Carlo.jl","title":"Merging jobs","text":"","category":"section"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"./myjob merge","category":"page"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"Usually Carlo will automatically merge results once a job is complete, but when you are impatient and you want to check on results of a running or aborted job, this command is your friend. It will produce a myjob.results.json file containing the averages of the currently available data.","category":"page"},{"location":"index.html#Deleting-jobs","page":"Carlo.jl","title":"Deleting jobs","text":"","category":"section"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"./myjob delete","category":"page"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"This deletes myjob.data and myjob.results.json. Of course, you should archive your simulation data instead of deleting them. However, if you made an error in a previous simulation, keep in mind that by default Carlo will continue it from the checkpoints.","category":"page"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"For that case of restarting a job there is a handy shortcut as well","category":"page"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"./myjob run --restart","category":"page"},{"location":"index.html#Shortcuts","page":"Carlo.jl","title":"Shortcuts","text":"","category":"section"},{"location":"index.html","page":"Carlo.jl","title":"Carlo.jl","text":"All commands here have shortcut versions that you can view in the help.","category":"page"},{"location":"rng.html#rng","page":"Random Number Generators","title":"Random Number Generators","text":"","category":"section"},{"location":"rng.html","page":"Random Number Generators","title":"Random Number Generators","text":"Carlo takes care of storing and managing the state of random number generators (RNG) for you. It is accessible through the rng field of MCContext and the type of RNG to use can be set by the rng parameter in every task (see TaskInfo).","category":"page"},{"location":"rng.html","page":"Random Number Generators","title":"Random Number Generators","text":"The currently supported types are","category":"page"},{"location":"rng.html","page":"Random Number Generators","title":"Random Number Generators","text":"Random.Xoshiro","category":"page"}]
}
